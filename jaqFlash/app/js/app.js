var d = document,
example="70,87,83,5,181,8,1,0,112,0,13,172,0,0,156,64,0,30,115,0,67,2,0,0,0,191,3,185,5,0,0,1,0,38,111,21,0,0,125,6,255,227,32,192,0,0,0,2,88,1,64,0,0,240,51,200,129,102,27,32,6,60,24,19,17,173,48,55,246,192,225,139,238,132,14,187,80,14,78,109,253,128,196,141,3,34,68,5,11,131,99,159,248,130,130,148,30,200,0,224,255,240,109,152,90,56,156,196,0,40,142,63,255,192,8,32,54,208,64,1,31,148,136,128,92,255,255,254,24,172,64,48,219,8,33,20,26,100,48,136,12,127,255,255,255,227,32,192,91,37,67,230,128,1,148,160,0,248,96,49,0,196,160,44,129,192,61,151,13,8,24,173,199,24,98,79,255,255,255,199,3,14,97,4,42,40,128,21,8,161,0,42,22,199,32,112,10,95,255,255,255,255,252,116,10,80,46,12,78,229,113,65,139,44,151,38,255,155,233,186,225,77,171,145,10,75,88,141,237,33,179,64,141,197,106,165,76,152,148,11,24,191,197,218,136,187,180,92,255,227,32,192,33,18,136,226,201,145,216,48,1,181,41,169,158,47,27,218,154,170,127,237,85,109,143,56,242,212,79,65,249,52,177,190,111,197,248,255,253,228,73,23,32,167,154,18,239,224,86,177,21,245,0,192,16,113,88,172,104,152,29,6,109,13,82,37,141,178,180,183,61,127,255,255,255,252,124,24,8,103,255,255,255,229,14,23,18,59,255,255,253,77,56,40,71,255,255,253,11,155,49,228,255,227,32,192,49,16,195,38,211,242,74,142,218,142,60,223,255,245,48,241,169,167,29,255,155,25";
function e(i){return d.getElementById(i);}
function log(s) {
	e('log').innerHTML += '<div style="color:blue;">' + s + '</div>';
}
function testGetSwfSize() {
	getSwfSize(example);
}

function _toFullByte(n) {
	var n = Number(n).toString(2);
	while (n.length < 8) {
		n = '0' + n;
	}
	return n;
}

function getSwfSize(data) {
	log('Hello');
	var numRByte = 8, a = data.split(','),
		szByte = a[numRByte], s, n, i, k, aB = [], j, aR = [], q = '', szSide, nBytes, nBits, 
		//nDiff - разность между целым числом бит в nBytes b реальным числом бит в RECT nBits
		nDiff;
	s = _toFullByte(szByte);
	log(s);
	//get side length
	s = s.substring(0, 5);
	//s = s.substring(3);
	log('size in unsigned bits:' + s);
	n = parseInt(s, 2);
	log('size in dec:' + n);
	szSide = n;
	//calculate num bits
	n = n*4 + 5;
	nBits = n;
	log('bits in rect structure:' + n);
	n = Math.ceil(n / 8);
	nBytes = n;
	log('bytes in rect structure:' + n);
	nDiff = 8*nBytes - nBits;
	log('nDiff:' + nDiff);
	//get binary str
	s = '';
	for (i = numRByte; i < numRByte + nBytes + 1; i++) {
		n = Number(a[i]);
		if (String(n) == 'undefined') {
			alert('ATAS');
		}
		//if (i == 65) {
			//s += _toFullByte(n);
		//} else {
			s += Number(n).toString(2);
		//}
	}
	log('rect:' + s);
	log('srelen(rect):' + s.length);
	log('szSide:' + szSide);
	k = 0;
	for (j = 0, i = s.length - (1 + nDiff); i > -1; i--, j++, k++) {
		if (k == 0) {
			log('i = ' + i);
		}
		aB.push(s.charAt(i));
		if (j + 1 == szSide) {
			aR.push( aB.reverse().join('') );
			j = -1;
			aB = [];
		}
	}
	for (i = 0; i < aR.length; i++) {
		log('side ' + i + ' = "' + aR[i] + '", dec = ' + parseInt(aR[i], 2));
	}
}
window.onload=testGetSwfSize;

/*
 * скопировал верно
 
01110000 00000000 00001101 10101100 00000000 00000000 10011100 00000000 00011110 01110011
01110000 00000000 00001101 10101100 00000000 00000000 10011100 00000000 00011110 01110011

//5 бит 
//3 бита лишних


//справа
01110
00000000000000
01101101011000
00000000000000
01001110000000
000
//и всё сходится, если поджелить на 20-ку, как и надо)))
*/
